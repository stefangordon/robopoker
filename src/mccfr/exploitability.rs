//! Exploitability evaluation using Monte Carlo best response sampling.
//!
//! Measures how much a strategy can be exploited by computing the Nash gap:
//! the difference between best response and strategy values. Uses statistical
//! stopping with confidence intervals for efficient evaluation.

use crate::{
    cards::{evaluator::Evaluator, hand::Hand, street::Street},
    mccfr::{
        nlhe::{edge::Edge, encoder::Encoder, game::Game, info::Info, solver::NLHE, turn::Turn},
        structs::tree::Tree,
        traits::{
            blueprint::Blueprint, encoder::Encoder as EncoderTrait, game::Game as GameTrait,
            profile::Profile,
        },
    },
    save::disk::Disk,
    Arbitrary, B_BLIND,
};

use petgraph::graph::NodeIndex;
use rand::{rngs::SmallRng, SeedableRng};
use rayon::prelude::*;
use std::{
    cmp::Ordering,
    time::{Duration, Instant},
};

// Evaluation configuration
const TRAVERSALS_PER_HAND: usize = 100;  // Independent search traversals per hole-card deal
const BATCH_SIZE: usize = 20; // Number of games per batch

const MAX_DEPTH: usize = 12;
const TARGET_CI_WIDTH: f64 = 5.0; // ±5 mbb/hand
const MIN_SAMPLES: u64 = 100;
const PROGRESS_DELAY_MS: u64 = 100;
const EQUITY_SAMPLES: usize = 10_000;

/// Runs exploitability evaluation with statistical stopping.
pub async fn evaluate() {
    let solver = load_solver().await;
    let mut stats = WelfordStats::new();
    let start_time = Instant::now();

    log::info!("Starting exploitability evaluation");
    log::info!("Target confidence interval: ±{TARGET_CI_WIDTH} mbb/hand");
    log::info!("Batch size: {} games, Traversals per hand: {}", BATCH_SIZE, TRAVERSALS_PER_HAND);

    loop {
        log::info!("Starting batch {} (total samples so far: {})...", stats.count() / BATCH_SIZE as u64 + 1, stats.count());
        let batch_start = Instant::now();

        let batch_results = evaluate_batch(&solver).await;

        let batch_duration = batch_start.elapsed();
        log::info!("Batch completed in {:.1}s", batch_duration.as_secs_f64());

        batch_results
            .iter()
            .for_each(|&result| stats.update(result));
        let samples = stats.count();

        let (mean, ci_width) = stats.confidence_interval();
        let rate = samples as f64 / start_time.elapsed().as_secs_f64();
        let elapsed = start_time.elapsed();

                // Estimate progress towards convergence
        let progress_msg = if samples >= MIN_SAMPLES {
            let ci_progress = (TARGET_CI_WIDTH / ci_width).min(1.0) * 100.0;
            format!("CI progress: {:.1}% (target: ±{:.1})", ci_progress, TARGET_CI_WIDTH)
        } else {
            let sample_progress = (samples as f64 / MIN_SAMPLES as f64) * 100.0;
            format!("Sample progress: {:.1}% ({}/{})", sample_progress, samples, MIN_SAMPLES)
        };

        log::info!("Progress: {} samples in {:.1}s | Exploitability: {:.2} ± {:.2} mbb/hand | Rate: {:.1}/sec | {}",
                  samples, elapsed.as_secs_f64(), mean, ci_width, rate, progress_msg);

        if samples >= MIN_SAMPLES && ci_width <= TARGET_CI_WIDTH {
            log::info!("✓ Converged: {:.2} mbb/hand after {:.1}s", mean, elapsed.as_secs_f64());
            break;
        }

        tokio::time::sleep(Duration::from_millis(PROGRESS_DELAY_MS)).await;
    }
}

async fn load_solver() -> NLHE {
    log::info!("Loading trained solver...");
    NLHE::load(Street::random())
}

async fn evaluate_batch(solver: &NLHE) -> Vec<f64> {
    use std::sync::atomic::{AtomicUsize, Ordering};

    let completed = AtomicUsize::new(0);
    let total = BATCH_SIZE;

    let results: Vec<f64> = (0..total)
        .into_par_iter()
        .map(|_i| {
            let mut rng = SmallRng::from_entropy();
            let game = Game::root();
            let result =
                compute_exploitability(&game, solver.profile(), solver.encoder(), &mut rng);

            let done = completed.fetch_add(1, Ordering::Relaxed) + 1;
            // Show progress every 25% of batch completion, but not too frequently
            let progress_interval = (total / 4).max(1);
            if done % progress_interval == 0 || done == total {
                log::info!("  → Batch progress: {}/{} games ({:.0}%)",
                          done, total, (done as f64 / total as f64) * 100.0);
            }

            result
        })
        .collect();

    results
}

/// Computes exploitability for a single game using Monte Carlo rollouts.
fn compute_exploitability(
    game: &Game,
    profile: &super::nlhe::profile::Profile,
    encoder: &Encoder,
    rng: &mut SmallRng,
) -> f64 {
    // For nested parallelism, we can't use mutable trees across threads
    // Each rollout will create its own trees

    (0..TRAVERSALS_PER_HAND)
        .map(|_| {
            // Each rollout gets its own trees
            let mut br_tree = Tree::default();
            let mut strategy_tree = Tree::default();

            let br_values = [0, 1].map(|player| {
                best_response_value(game, profile, encoder, &mut br_tree, player, MAX_DEPTH, rng)
            });

            let strategy_values = [0, 1].map(|player| {
                strategy_value(
                    game,
                    profile,
                    encoder,
                    &mut strategy_tree,
                    player,
                    MAX_DEPTH,
                    rng,
                )
            });

            let exploitability = br_values
                .iter()
                .zip(&strategy_values)
                .map(|(br, strat)| br - strat)
                .sum::<f64>()
                / 2.0; // Standard formula

            exploitability * 1000.0 / B_BLIND as f64 // Convert to mbb/hand
        })
        .sum::<f64>()
        / TRAVERSALS_PER_HAND as f64
}

/// Computes best response value using perfect play for the target player.
fn best_response_value(
    game: &Game,
    profile: &super::nlhe::profile::Profile,
    encoder: &Encoder,
    tree: &mut Tree<Turn, Edge, Game, Info>,
    player: usize,
    depth: usize,
    rng: &mut SmallRng,
) -> f64 {
    // Seed root node
    let root_info = encoder.seed(game);
    let root_node = tree.seed(root_info, game.clone());
    best_response_node_value(
        root_node.index(),
        profile,
        encoder,
        tree,
        player,
        depth,
        1.0,
        rng,
    )
}

/// Recursive helper that traverses the tree using encoder.info()
fn best_response_node_value(
    node_idx: NodeIndex,
    profile: &super::nlhe::profile::Profile,
    encoder: &Encoder,
    tree: &mut Tree<Turn, Edge, Game, Info>,
    player: usize,
    depth: usize,
    reach: f64,
    _rng: &mut SmallRng,
) -> f64 {
    let node = tree.at(node_idx);
    let game = node.game();

    if depth == 0 {
        log::trace!(
            "BR depth limited at street {:?}, pot={}, turn={:?}",
            game.street(),
            game.pot(),
            game.turn()
        );
        return reach * estimate_leaf_value(game, player);
    }

    // Generate branches (legal edges) from this node
    let branches = encoder.branches(&node);
    if branches.is_empty() {
        return reach * game.payoff(Turn::Choice(player)) as f64;
    }

    match game.turn() {
        Turn::Chance => {
            let prob = 1.0 / branches.len() as f64;
            branches
                .iter()
                .map(|(edge, next_game, _)| {
                    let child_info =
                        encoder.info(tree, (edge.clone(), next_game.clone(), node_idx));
                    let child_node =
                        tree.grow(child_info, (edge.clone(), next_game.clone(), node_idx));
                    best_response_node_value(
                        child_node.index(),
                        profile,
                        encoder,
                        tree,
                        player,
                        depth - 1,
                        reach * prob,
                        _rng,
                    )
                })
                .sum()
        }

        Turn::Choice(p) if p == player => {
            // Player chooses the action that maximises expected value.
            branches
                .iter()
                .map(|(edge, next_game, _)| {
                    let child_info =
                        encoder.info(tree, (edge.clone(), next_game.clone(), node_idx));
                    let child_node =
                        tree.grow(child_info, (edge.clone(), next_game.clone(), node_idx));
                    best_response_node_value(
                        child_node.index(),
                        profile,
                        encoder,
                        tree,
                        player,
                        depth - 1,
                        reach,
                        _rng,
                    )
                })
                .fold(f64::NEG_INFINITY, f64::max)
        }

        Turn::Choice(_) => {
            // Opponent follows their strategy – take expectation over their mixed strategy.
            let probs = normalize_probabilities(&branches, profile, node.info());
            branches
                .iter()
                .zip(&probs)
                .map(|((edge, next_game, _), prob)| {
                    let child_info =
                        encoder.info(tree, (edge.clone(), next_game.clone(), node_idx));
                    let child_node =
                        tree.grow(child_info, (edge.clone(), next_game.clone(), node_idx));
                    best_response_node_value(
                        child_node.index(),
                        profile,
                        encoder,
                        tree,
                        player,
                        depth - 1,
                        reach * *prob,
                        _rng,
                    )
                })
                .sum()
        }

        Turn::Terminal => reach * game.payoff(Turn::Choice(player)) as f64,
    }
}

/// Computes strategy value using the current profile for both players.
fn strategy_value(
    game: &Game,
    profile: &super::nlhe::profile::Profile,
    encoder: &Encoder,
    tree: &mut Tree<Turn, Edge, Game, Info>,
    player: usize,
    depth: usize,
    rng: &mut SmallRng,
) -> f64 {
    let root_info = encoder.seed(game);
    let root_node = tree.seed(root_info, game.clone());
    strategy_node_value(
        root_node.index(),
        profile,
        encoder,
        tree,
        player,
        depth,
        1.0,
        rng,
    )
}

/// Recursive helper for average-strategy rollout
fn strategy_node_value(
    node_idx: NodeIndex,
    profile: &super::nlhe::profile::Profile,
    encoder: &Encoder,
    tree: &mut Tree<Turn, Edge, Game, Info>,
    player: usize,
    depth: usize,
    reach: f64,
    _rng: &mut SmallRng,
) -> f64 {
    let node = tree.at(node_idx);
    let game = node.game();

    if depth == 0 {
        return reach * estimate_leaf_value(game, player);
    }

    let branches = encoder.branches(&node);
    if branches.is_empty() {
        return reach * game.payoff(Turn::Choice(player)) as f64;
    }

    match game.turn() {
        Turn::Chance => {
            let prob = 1.0 / branches.len() as f64;
            branches
                .iter()
                .map(|(edge, next_game, _)| {
                    let child_info =
                        encoder.info(tree, (edge.clone(), next_game.clone(), node_idx));
                    let child_node =
                        tree.grow(child_info, (edge.clone(), next_game.clone(), node_idx));
                    strategy_node_value(
                        child_node.index(),
                        profile,
                        encoder,
                        tree,
                        player,
                        depth - 1,
                        reach * prob,
                        _rng,
                    )
                })
                .sum()
        }

        Turn::Choice(_) => {
            let probs = normalize_probabilities(&branches, profile, node.info());
            branches
                .iter()
                .zip(&probs)
                .map(|((edge, next_game, _), prob)| {
                    let child_info =
                        encoder.info(tree, (edge.clone(), next_game.clone(), node_idx));
                    let child_node =
                        tree.grow(child_info, (edge.clone(), next_game.clone(), node_idx));
                    strategy_node_value(
                        child_node.index(),
                        profile,
                        encoder,
                        tree,
                        player,
                        depth - 1,
                        reach * *prob,
                        _rng,
                    )
                })
                .sum()
        }

        Turn::Terminal => reach * game.payoff(Turn::Choice(player)) as f64,
    }
}

type TreeBranches = Vec<(Edge, Game, petgraph::graph::NodeIndex)>;

fn normalize_probabilities(
    branches: &TreeBranches,
    profile: &super::nlhe::profile::Profile,
    info: &Info,
) -> Vec<f64> {
    let mut probs: Vec<f64> = branches
        .iter()
        .map(|(edge, _, _)| profile.advice(info, edge) as f64)
        .collect();

    let sum: f64 = probs.iter().sum();
    if sum > 0.0 {
        probs.iter_mut().for_each(|p| *p /= sum);
    } else {
        let len = probs.len() as f64;
        probs.fill(1.0 / len);
    }
    probs
}

/// Estimates leaf node value using equity calculation.
fn estimate_leaf_value(game: &Game, player: usize) -> f64 {
    // Expected share of the pot minus chips already committed by the hero.
    // This avoids double-counting the hero's contribution and keeps the value
    // bounded within ±(pot / 2) chips.

    let pot = game.pot() as f64;
    let equity = compute_equity(game, player);

    // Chips hero has risked so far (part of the pot already).
    let committed = game.spent(player) as f64;

    equity * pot - committed
}

/// Computes hero's equity against the opponent using their actual hole cards
/// and exhaustive enumeration over the remaining community cards.
fn compute_equity(game: &Game, hero_player: usize) -> f64 {
    // Known hole cards for both players
    let hero_hole = Hand::from(game.hole_cards(hero_player));
    let villain_hole = Hand::from(game.hole_cards(1 - hero_player));

    let board = Hand::from(game.board());

    // Debug: Check for card conflicts
    #[cfg(debug_assertions)]
    {
        let all_cards = Hand::add(Hand::add(hero_hole, villain_hole), board);
        let card_count = Vec::from(all_cards).len();
        let expected_count = hero_hole.size() + villain_hole.size() + board.size();
        if card_count != expected_count {
            eprintln!(
                "WARNING: Card conflict detected! Expected {} cards, found {}",
                expected_count, card_count
            );
            eprintln!(
                "Hero: {}, Villain: {}, Board: {}",
                hero_hole, villain_hole, board
            );
        }
    }

    street_equity(hero_hole, villain_hole, board, game.street())
}

/// Exact equity calculation using exhaustive board enumeration where feasible.
fn street_equity(hero: Hand, villain: Hand, board: Hand, _street: Street) -> f64 {
    // Create full deck and remove known cards
    let mut remaining = Hand::from(Hand::mask()); // Full 52-card deck

    // Remove known cards
    for card in Vec::from(Hand::add(Hand::add(hero, villain), board)) {
        remaining.remove(card);
    }

    let cards_needed = 5_usize.saturating_sub(board.size());

    // Debug: check deck size
    #[cfg(debug_assertions)]
    {
        let remaining_count = Vec::from(remaining).len();
        let expected_remaining = 52 - hero.size() - villain.size() - board.size();
        if remaining_count != expected_remaining {
            eprintln!(
                "WARNING: Deck size mismatch! Expected {} remaining cards, found {}",
                expected_remaining, remaining_count
            );
        }
    }

    if cards_needed == 0 {
        // Board is complete – direct showdown evaluation, no sampling needed.
        return evaluate_completed_hands(hero, villain, board);
    }

    // Unified Monte-Carlo path for 1–5 unknown community cards.
    let remaining_cards: Vec<_> = remaining.collect();
    let mut rng = rand::thread_rng();
    let mut sum = 0.0f64;
    for _ in 0..EQUITY_SAMPLES {
        // Sample `cards_needed` distinct indices without replacement.
        let sample = rand::seq::index::sample(&mut rng, remaining_cards.len(), cards_needed);
        let mut extended_board = board;
        for idx in sample {
            extended_board = Hand::add(extended_board, Hand::from(remaining_cards[idx]));
        }
        sum += evaluate_completed_hands(hero, villain, extended_board);
    }

    sum / EQUITY_SAMPLES as f64
}

/// Evaluate two hands against a completed 5-card board.
fn evaluate_completed_hands(hero: Hand, villain: Hand, board: Hand) -> f64 {
    let hero_hand = Hand::add(hero, board);
    let villain_hand = Hand::add(villain, board);

    let hero_eval = Evaluator::from(hero_hand);
    let villain_eval = Evaluator::from(villain_hand);
    let hero_ranking = hero_eval.find_ranking();
    let villain_ranking = villain_eval.find_ranking();

    match hero_ranking.cmp(&villain_ranking) {
        Ordering::Greater => 1.0,
        Ordering::Equal => 0.5,
        Ordering::Less => 0.0,
    }
}

/// Welford's online algorithm for computing running statistics.
#[derive(Debug, Clone)]
struct WelfordStats {
    count: u64,
    mean: f64,
    m2: f64, // Sum of squared deviations
}

impl WelfordStats {
    const fn new() -> Self {
        Self {
            count: 0,
            mean: 0.0,
            m2: 0.0,
        }
    }

    fn update(&mut self, value: f64) {
        self.count += 1;
        let delta = value - self.mean;
        self.mean += delta / self.count as f64;
        self.m2 += delta * (value - self.mean);
    }

    const fn count(&self) -> u64 {
        self.count
    }

    fn std_error(&self) -> f64 {
        if self.count < 2 {
            return f64::INFINITY;
        }
        let variance = self.m2 / (self.count - 1) as f64;
        (variance / self.count as f64).sqrt()
    }

    /// Returns (mean, 95% CI width).
    fn confidence_interval(&self) -> (f64, f64) {
        (self.mean, 1.96 * self.std_error())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cards::{card::Card, hand::Hand, rank::Rank, ranking::Ranking, suit::Suit};

    #[test]
    fn test_equity_logic_with_known_hands() {
        // Test a scenario where we know the outcome
        // Royal flush vs high card should be 100% equity

        // We'll create hands manually to test the core logic
        let royal_flush = Ranking::StraightFlush(Rank::Ace);
        let high_card = Ranking::HighCard(Rank::Ace);

        // Test the comparison directly
        let comparison = royal_flush.cmp(&high_card);

        match comparison {
            Ordering::Greater => {
                println!("✓ CORRECT: Royal flush > high card (Greater)");
                assert!(true);
            }
            Ordering::Less => {
                println!("❌ BUG: Royal flush < high card (Less) - COMPARISON IS BACKWARDS!");
                panic!("Ranking comparison is backwards! Royal flush should beat high card");
            }
            Ordering::Equal => {
                println!("❌ BUG: Royal flush = high card (Equal) - This shouldn't happen");
                panic!("Ranking comparison failed - royal flush equals high card");
            }
        }

        // Test the actual function that would be called
        let hero_wins_result = match royal_flush.cmp(&high_card) {
            Ordering::Greater => 1.0, // Hero wins
            Ordering::Equal => 0.5,   // Tie
            Ordering::Less => 0.0,    // Hero loses
        };

        assert_eq!(
            hero_wins_result, 1.0,
            "Royal flush should beat high card (equity = 1.0)"
        );
        println!("✓ Equity calculation logic is correct");
    }

    // WelfordStats tests
    #[test]
    fn test_welford_stats_new() {
        let stats = WelfordStats::new();
        assert_eq!(stats.count(), 0);
        assert_eq!(stats.mean, 0.0);
        assert_eq!(stats.m2, 0.0);
    }

    #[test]
    fn test_welford_stats_single_value() {
        let mut stats = WelfordStats::new();
        stats.update(5.0);

        assert_eq!(stats.count(), 1);
        let (mean, ci_width) = stats.confidence_interval();
        assert_eq!(mean, 5.0);
        // With only one sample, confidence interval should be infinite
        assert!(ci_width.is_infinite());
    }

    #[test]
    fn test_welford_stats_two_values() {
        let mut stats = WelfordStats::new();
        stats.update(1.0);
        stats.update(3.0);

        assert_eq!(stats.count(), 2);
        let (mean, ci_width) = stats.confidence_interval();
        assert_eq!(mean, 2.0); // Mean of [1, 3] is 2

        // Standard error = std_dev / sqrt(n) = sqrt(2) / sqrt(2) = 1.0
        let expected_ci_width = 1.96 * 1.0; // 95% CI
        assert!((ci_width - expected_ci_width).abs() < 1e-10);
    }

    #[test]
    fn test_welford_stats_known_sequence() {
        let mut stats = WelfordStats::new();
        let values = [1.0, 2.0, 3.0, 4.0, 5.0];

        for &val in &values {
            stats.update(val);
        }

        assert_eq!(stats.count(), 5);
        let (mean, _) = stats.confidence_interval();
        assert!((mean - 3.0).abs() < 1e-10); // Mean should be 3.0

        // Variance of [1,2,3,4,5] is 2.5, std_dev = sqrt(2.5) ≈ 1.5811
        // Standard error = 1.5811 / sqrt(5) ≈ 0.7071
        let std_error = stats.std_error();
        let expected_std_error = (2.5_f64).sqrt() / (5.0_f64).sqrt();
        assert!((std_error - expected_std_error).abs() < 1e-10);
    }

    #[test]
    fn test_welford_stats_identical_values() {
        let mut stats = WelfordStats::new();
        for _ in 0..10 {
            stats.update(42.0);
        }

        assert_eq!(stats.count(), 10);
        let (mean, ci_width) = stats.confidence_interval();
        assert_eq!(mean, 42.0);
        assert_eq!(ci_width, 0.0); // No variance means no confidence interval
    }

    #[test]
    fn test_welford_stats_negative_values() {
        let mut stats = WelfordStats::new();
        stats.update(-5.0);
        stats.update(-3.0);
        stats.update(-1.0);

        assert_eq!(stats.count(), 3);
        let (mean, _) = stats.confidence_interval();
        assert_eq!(mean, -3.0); // Mean of [-5, -3, -1] is -3
    }

    // evaluate_completed_hands tests

    #[test]
    fn test_evaluate_completed_hands_pair_vs_pair() {
        // Hero has pocket aces
        let hero = Hand::from(vec![
            Card::from((Rank::Ace, Suit::H)),
            Card::from((Rank::Ace, Suit::S)),
        ]);

        // Villain has pocket kings
        let villain = Hand::from(vec![
            Card::from((Rank::King, Suit::H)),
            Card::from((Rank::King, Suit::S)),
        ]);

        // Board doesn't improve either hand significantly
        let board = Hand::from(vec![
            Card::from((Rank::Two, Suit::C)),
            Card::from((Rank::Three, Suit::C)),
            Card::from((Rank::Four, Suit::C)),
            Card::from((Rank::Five, Suit::D)),
            Card::from((Rank::Seven, Suit::H)),
        ]);

        let result = evaluate_completed_hands(hero, villain, board);
        assert_eq!(result, 1.0, "Pocket aces should beat pocket kings");
    }

    #[test]
    fn test_evaluate_completed_hands_simple_comparison() {
        // Hero has a high pair
        let hero = Hand::from(vec![
            Card::from((Rank::King, Suit::H)),
            Card::from((Rank::King, Suit::S)),
        ]);

        // Villain has a lower pair
        let villain = Hand::from(vec![
            Card::from((Rank::Queen, Suit::H)),
            Card::from((Rank::Queen, Suit::S)),
        ]);

        // Board doesn't help either player much
        let board = Hand::from(vec![
            Card::from((Rank::Two, Suit::C)),
            Card::from((Rank::Seven, Suit::D)),
            Card::from((Rank::Nine, Suit::D)),
            Card::from((Rank::Jack, Suit::H)),
            Card::from((Rank::Ace, Suit::C)),
        ]);

        let result = evaluate_completed_hands(hero, villain, board);
        assert_eq!(result, 1.0, "Pocket kings should beat pocket queens");
    }

    #[test]
    fn test_evaluate_completed_hands_exact_tie() {
        // Create an exact tie scenario
        let hero = Hand::from(vec![
            Card::from((Rank::Ace, Suit::H)),
            Card::from((Rank::Two, Suit::C)),
        ]);

        let villain = Hand::from(vec![
            Card::from((Rank::Ace, Suit::S)),
            Card::from((Rank::Two, Suit::H)),
        ]);

        // Board that makes both hands identical in value
        let board = Hand::from(vec![
            Card::from((Rank::King, Suit::C)),
            Card::from((Rank::Queen, Suit::C)),
            Card::from((Rank::Jack, Suit::C)),
            Card::from((Rank::Ten, Suit::C)),
            Card::from((Rank::Nine, Suit::C)),
        ]);

        let result = evaluate_completed_hands(hero, villain, board);
        assert_eq!(result, 0.5, "Identical hand values should result in a tie");
    }

    #[test]
    fn test_evaluate_completed_hands_flush_vs_straight() {
        // Hero makes a flush
        let hero = Hand::from(vec![
            Card::from((Rank::Ace, Suit::H)),
            Card::from((Rank::King, Suit::H)),
        ]);

        // Villain makes a straight
        let villain = Hand::from(vec![
            Card::from((Rank::Queen, Suit::S)),
            Card::from((Rank::Jack, Suit::C)),
        ]);

        // Board that gives hero flush and villain straight
        let board = Hand::from(vec![
            Card::from((Rank::Ten, Suit::H)),
            Card::from((Rank::Nine, Suit::H)),
            Card::from((Rank::Eight, Suit::H)),
            Card::from((Rank::Seven, Suit::S)),
            Card::from((Rank::Two, Suit::C)),
        ]);

        let result = evaluate_completed_hands(hero, villain, board);
        assert_eq!(result, 1.0, "Flush should beat straight");
    }

    #[test]
    fn test_street_equity_simple() {
        use crate::cards::{card::Card, hand::Hand, rank::Rank, street::Street, suit::Suit};

        // Test with AA vs KK, no board
        let hero = Hand::from(vec![
            Card::from((Rank::Ace, Suit::H)),
            Card::from((Rank::Ace, Suit::S)),
        ]);
        let villain = Hand::from(vec![
            Card::from((Rank::King, Suit::D)),
            Card::from((Rank::King, Suit::C)),
        ]);
        let board = Hand::empty();

        let equity = super::street_equity(hero, villain, board, Street::Pref);
        println!("AA vs KK preflop equity: {}", equity);

        // AA should be about 80% favorite
        assert!(
            equity > 0.75 && equity < 0.85,
            "AA vs KK should be ~80%, got {}",
            equity
        );
    }

    #[test]
    fn test_street_equity_exact() {
        use crate::cards::{card::Card, hand::Hand, rank::Rank, street::Street, suit::Suit};

        // Test with a flop already dealt - only need 2 more cards (exact calculation)
        let p1 = Hand::from(vec![
            Card::from((Rank::Ace, Suit::H)),
            Card::from((Rank::Ace, Suit::D)),
        ]);
        let p2 = Hand::from(vec![
            Card::from((Rank::King, Suit::S)),
            Card::from((Rank::King, Suit::C)),
        ]);

        // Flop: 2h 3c 4d (doesn't help either hand)
        let board = Hand::from(vec![
            Card::from((Rank::Two, Suit::H)),
            Card::from((Rank::Three, Suit::C)),
            Card::from((Rank::Four, Suit::D)),
        ]);

        let eq1 = super::street_equity(p1, p2, board, Street::Flop);
        let eq2 = super::street_equity(p2, p1, board, Street::Flop);

        println!("AA vs KK on flop - AA equity: {}", eq1);
        println!("AA vs KK on flop - KK equity: {}", eq2);
        println!("Sum: {} (should be exactly 1.0)", eq1 + eq2);

        // With Monte-Carlo sampling the result is unbiased but noisy – allow a small tolerance.
        assert!(
            (eq1 + eq2 - 1.0).abs() < 0.02,
            "Equity should sum to ~1.0 (tolerance ±0.02), got {} + {} = {}",
            eq1,
            eq2,
            eq1 + eq2
        );
    }

    #[test]
    fn test_street_equity_symmetry() {
        use crate::cards::{card::Card, hand::Hand, rank::Rank, street::Street, suit::Suit};

        // Simple test: KK vs QQ
        let p1 = Hand::from(vec![
            Card::from((Rank::King, Suit::H)),
            Card::from((Rank::King, Suit::D)),
        ]);
        let p2 = Hand::from(vec![
            Card::from((Rank::Queen, Suit::S)),
            Card::from((Rank::Queen, Suit::C)),
        ]);

        let eq1 = super::street_equity(p1, p2, Hand::empty(), Street::Pref);
        let eq2 = super::street_equity(p2, p1, Hand::empty(), Street::Pref);

        println!("KK vs QQ equity: {}", eq1);
        println!("QQ vs KK equity: {}", eq2);
        println!("Sum: {}", eq1 + eq2);

        // With Monte Carlo sampling, we need a slightly larger tolerance
        assert!(
            (eq1 + eq2 - 1.0).abs() < 0.005,
            "Direct equity calc should sum to ~1.0, got {} + {} = {}",
            eq1,
            eq2,
            eq1 + eq2
        );
    }

    #[test]
    fn test_compute_equity_symmetry() {
        use crate::cards::{card::Card, hand::Hand, hole::Hole, rank::Rank, suit::Suit};
        use crate::mccfr::nlhe::game::Game;

        // Create specific hole cards
        let p0_hole = Hole::from(Hand::from(vec![
            Card::from((Rank::King, Suit::H)),
            Card::from((Rank::King, Suit::S)),
        ]));
        let p1_hole = Hole::from(Hand::from(vec![
            Card::from((Rank::Queen, Suit::D)),
            Card::from((Rank::Queen, Suit::C)),
        ]));

        // Create game with specific cards
        let game = Game::base()
            .deal() // This creates the game structure
            .reset_cards_at(0, p0_hole)
            .reset_cards_at(1, p1_hole)
            .post(); // Post blinds

        let eq_p0 = super::compute_equity(&game, 0);
        let eq_p1 = super::compute_equity(&game, 1);

        // Debug print
        println!(
            "P0 equity: {}, P1 equity: {}, Sum: {}",
            eq_p0,
            eq_p1,
            eq_p0 + eq_p1
        );

        assert!(
            (eq_p0 + eq_p1 - 1.0).abs() < 0.02,
            "Equity should sum to ~1.0 (tolerance ±0.02), got {} + {} = {}",
            eq_p0,
            eq_p1,
            eq_p0 + eq_p1
        );
    }

    #[test]
    fn test_compute_equity_aces_vs_seven_deuce() {
        use crate::cards::{card::Card, hand::Hand, hole::Hole, rank::Rank, suit::Suit};
        use crate::mccfr::nlhe::game::Game;

        // Pocket Aces for player 0
        let hero_hand = Hand::from(vec![
            Card::from((Rank::Ace, Suit::H)),
            Card::from((Rank::Ace, Suit::S)),
        ]);
        let hero_hole = Hole::from(hero_hand);

        // 7♣ 2♦ for player 1 – widely regarded as the weakest starting hand
        let villain_hand = Hand::from(vec![
            Card::from((Rank::Seven, Suit::C)),
            Card::from((Rank::Two, Suit::D)),
        ]);
        let villain_hole = Hole::from(villain_hand);

        let game = Game::base()
            .deal()
            .reset_cards_at(0, hero_hole)
            .reset_cards_at(1, villain_hole)
            .post();

        let eq_hero = super::compute_equity(&game, 0);
        let eq_villain = super::compute_equity(&game, 1);

        // Basic sanity checks – hero should be a clear favourite pre-flop
        assert!(
            eq_hero > 0.7,
            "Pocket aces should have >70% equity against 7-2o, got {}",
            eq_hero
        );
        assert!(
            eq_villain < 0.3,
            "7-2o should have <30% equity against pocket aces, got {}",
            eq_villain
        );
        assert!(
            (eq_hero + eq_villain - 1.0).abs() < 0.001,
            "Equities should sum to 1.0, got {} + {} = {}",
            eq_hero,
            eq_villain,
            eq_hero + eq_villain
        );
    }
}
